<?xml version="1.0" encoding="UTF-8"?><w:document xmlns:w="http://schemas.openxmlformats.org/wordprocessingml/2006/main"><w:body><w:p><w:pPr><w:pStyle w:val="title"/><w:jc w:val="center"/></w:pPr><w:r><w:t>Computer Vision</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="title"/><w:jc w:val="center"/></w:pPr><w:r><w:rPr><w:b/></w:rPr><w:t>Lab 2. </w:t></w:r><w:r><w:t>Basic Image Processing Techniques</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="text"/><w:jc w:val="left"/></w:pPr><w:r><w:t></w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="text"/><w:jc w:val="left"/></w:pPr><w:r><w:rPr><w:b/></w:rPr><w:t></w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="text"/><w:jc w:val="left"/></w:pPr><w:r><w:rPr><w:b/></w:rPr><w:t>Student(s):</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="text"/><w:jc w:val="left"/></w:pPr><w:r><w:rPr><w:b/></w:rPr><w:t></w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="text"/><w:jc w:val="left"/></w:pPr><w:r><w:rPr><w:b/></w:rPr><w:t>Date:</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="text"/><w:jc w:val="left"/></w:pPr><w:r><w:t></w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="text"/><w:jc w:val="left"/></w:pPr><w:r><w:t>The main objective of this practice is to become familiar with the basic image processing techniques using Matlab's </w:t></w:r><w:r><w:rPr><w:b/><w:i/></w:rPr><w:t>Image Processing Toolbox</w:t></w:r><w:r><w:t>. For this, exercises are proposed on geometric operations, histogram equalization, design and implementation of filters, noise elimination, image filtering in the space and frequency domain. Most enhancement techniques are applied to intensity (grayscale) images. To improve an RGB image, we will normally work with the matrices of the red, green and blue components separately. To carry out the exercises, it is initially proposed to use the images available in the virtual classroom of the subject, but others can be used as long as the format and luminosity characteristics required by the exercise are maintained (for example, if they must be in color, indexed, dark, with low contrast, etc...). In any case, it is very important to verify the format of each image before processing it: know if it is RGB, indexed, if the values are integers (uint8, etc.), or if they are float/double, since frequently the functions only work with a specific data type. This is especially important when the exercises do not indicate which conversion should be performed or when photos other than those initially indicated in the statement are used. If our image does not have the appropriate format, the functions may give an error (indicating the expected type of data) or provide an unexpected result. In either case we must verify the type of data expected by the function and change the image format with the appropriate conversion function.</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="text"/><w:jc w:val="left"/></w:pPr><w:r><w:rPr><w:b/></w:rPr><w:t>The practice report will be completed in this same .mlx file</w:t></w:r><w:r><w:t>, adding the name of the author/authors of the group, date, and inserting the code and pertinent comments in each section.</w:t></w:r><w:r><w:t> </w:t></w:r><w:r><w:t>The different parts will be independent sections (you must insert "section break" between them), and the results will be displayed together with subplot when appropriate. </w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="text"/><w:jc w:val="left"/></w:pPr><w:r><w:t>The </w:t></w:r><w:r><w:rPr><w:b/></w:rPr><w:t>delivery</w:t></w:r><w:r><w:t> will be made in the Virtual Classroom of the subject: Contents -&gt; Labs -&gt; Lab 2. Report.</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="code"/></w:pPr><w:r><w:t><![CDATA[clear all
close all]]></w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="text"/><w:jc w:val="left"/></w:pPr><w:r><w:t>Implement the following code, display the results obtained and justify them:</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="text"/><w:jc w:val="left"/></w:pPr><w:r><w:t>1. Open and view at least 2 color images, one RGB type and one indexed. To find out the format of each one you can previously use </w:t></w:r><w:r><w:rPr><w:i/></w:rPr><w:t>imageinfo</w:t></w:r><w:r><w:t> (RGB, indexed color map, etc.). When opening them you must use the appropriate variables (J, X, map, etc...) so that they are displayed correctly. Use different figures for each one (avoiding, in this case, the subplot command). </w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="code"/></w:pPr><w:r><w:t><![CDATA[]]></w:t></w:r></w:p><w:p><w:pPr><w:sectPr/></w:pPr></w:p><w:p><w:pPr><w:pStyle w:val="text"/><w:jc w:val="left"/></w:pPr><w:r><w:t>2. Convert the indexed image to grayscale (Igray image) and do the following with it:</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="text"/><w:jc w:val="left"/></w:pPr><w:r><w:t>    2.1 Modify the brightness and contrast. View the images (original and output) and their histograms together using the </w:t></w:r><w:r><w:rPr><w:i/></w:rPr><w:t>subplot</w:t></w:r><w:r><w:t> command. Explain when the modification is in brightness and when it is in contrast, justifying the values of the intervals used in each case..</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="text"/><w:jc w:val="left"/></w:pPr><w:r><w:t>    2.2 Binarize the Igris image with the </w:t></w:r><w:r><w:rPr><w:i/></w:rPr><w:t>im2bw</w:t></w:r><w:r><w:t> function and display the result.</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="text"/><w:jc w:val="left"/></w:pPr><w:r><w:t>    2.3 Obtain the negative of the Igris image.</w:t></w:r></w:p><w:p><w:pPr><w:sectPr/></w:pPr></w:p><w:p><w:pPr><w:pStyle w:val="text"/><w:jc w:val="left"/></w:pPr><w:r><w:t>3. Do the following with image "avion1.jpg":</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="text"/><w:jc w:val="left"/></w:pPr><w:r><w:t>    3.1 Apply the logarithm, previously calculating the optimal value of K, to ensure that the maximum gray level at the output is the maximum possible. View the original and output images and their histograms and observe the improvement obtained. Try using different K values than the one calculated and comment on the results.</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="text"/><w:jc w:val="left"/></w:pPr><w:r><w:t>    3.2 Perform a gamma correction. Try different gamma values and analyze the effect of each on the output image.</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="text"/><w:jc w:val="left"/></w:pPr><w:r><w:t>    3.3 Equalize its histogram with 256, 64 and 8 bins (see histeq help). View the images (original and output) and their histograms and comment on the differences.</w:t></w:r></w:p><w:p><w:pPr><w:sectPr/></w:pPr></w:p><w:p><w:pPr><w:pStyle w:val="text"/><w:jc w:val="left"/></w:pPr><w:r><w:t>4. Now work with image "matricula.jpg":</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="text"/><w:jc w:val="left"/></w:pPr><w:r><w:t>    4.1 Find out its dimensions (rows x columns). Resize it to be half the width and half the height. Display both images. To see the size change you must use the </w:t></w:r><w:r><w:rPr><w:i/></w:rPr><w:t>truesize</w:t></w:r><w:r><w:t> option after </w:t></w:r><w:r><w:rPr><w:i/></w:rPr><w:t>imshow</w:t></w:r><w:r><w:t> so that the images do not adjust their size to that of the window.</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="text"/><w:jc w:val="left"/></w:pPr><w:r><w:t>    4.2 Rotate it through an angle of 65.3º (for example), using the </w:t></w:r><w:r><w:rPr><w:i/></w:rPr><w:t>nearest</w:t></w:r><w:r><w:t> and </w:t></w:r><w:r><w:rPr><w:i/></w:rPr><w:t>bicubic</w:t></w:r><w:r><w:t> interpolation methods (parameters of the </w:t></w:r><w:r><w:rPr><w:i/></w:rPr><w:t>imrotate</w:t></w:r><w:r><w:t> function). Magnify the images enough to see the differences between both results and explain them.</w:t></w:r></w:p><w:p><w:pPr><w:sectPr/></w:pPr></w:p><w:p><w:pPr><w:pStyle w:val="text"/><w:jc w:val="left"/></w:pPr><w:r><w:t>5. Now use image "cell.tif":</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="text"/><w:jc w:val="left"/></w:pPr><w:r><w:t>    5.1 Obtain and display a version with uniformly distributed </w:t></w:r><w:r><w:rPr><w:i/></w:rPr><w:t>speckle</w:t></w:r><w:r><w:t> noise. Eliminate it with Wiener filtering and a low pass filter. Show the original, noisy and filtered images and compare them.</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="text"/><w:jc w:val="left"/></w:pPr><w:r><w:t>    5.2 Get a version with 5% noise density ‘salt and pepper’ noise. Filter it using a median filter and a low pass filter. Show the original, noisy and filtered images and compare them. Justify your conclusions.</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="text"/><w:jc w:val="left"/></w:pPr><w:r><w:t>    5.3 With a </w:t></w:r><w:r><w:rPr><w:i/></w:rPr><w:t>for</w:t></w:r><w:r><w:t> loop, obtain 32 different images by applying Gaussian noise of zero mean and variance 0.05 to "cell.tif" and save them using the </w:t></w:r><w:r><w:rPr><w:i/></w:rPr><w:t>imwrite</w:t></w:r><w:r><w:t> function in files with their respective names (noisy1.bmp, ..., noisy32.bmp). You can generate file names inside the </w:t></w:r><w:r><w:rPr><w:i/></w:rPr><w:t>for</w:t></w:r><w:r><w:t> loop using, for example: "noisy" + i + ".bmp". Perform noise filtering tests using the image averaging technique, first using 4 noisy images, then 8, then 16, and finally all 32. Visually compare the results (showing them in the same image with subplot) and comment on them.</w:t></w:r></w:p><w:p><w:pPr><w:sectPr/></w:pPr></w:p><w:p><w:pPr><w:pStyle w:val="text"/><w:jc w:val="left"/></w:pPr><w:r><w:t>6. Finally, use image "saturn.png" and:</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="text"/><w:jc w:val="left"/></w:pPr><w:r><w:t>    6.1 Convert it to gray levels (</w:t></w:r><w:r><w:rPr><w:i/></w:rPr><w:t>im2gray</w:t></w:r><w:r><w:t>) and then to double (</w:t></w:r><w:r><w:rPr><w:i/></w:rPr><w:t>im2double</w:t></w:r><w:r><w:t>).</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="text"/><w:jc w:val="left"/></w:pPr><w:r><w:t>    6.2 Add Gaussian noise of mean 0 and variance 0.01. View the original image and the noisy one.</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="text"/><w:jc w:val="left"/></w:pPr><w:r><w:t>    6.3 </w:t></w:r><w:r><w:rPr><w:b/></w:rPr><w:t>(Optional):</w:t></w:r><w:r><w:t> Obtain the FFT of the original image and the noisy image. show them.</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="text"/><w:jc w:val="left"/></w:pPr><w:r><w:t>    6.4 Apply the following filters to the noisy image and show and compare the effect of each on the output images. Justify the differences/similarities. The filters to apply are:</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="ListParagraph"/><w:numPr><w:numId w:val="1"/></w:numPr><w:jc w:val="left"/></w:pPr><w:r><w:t>A Wiener filter in the space domain.</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="ListParagraph"/><w:numPr><w:numId w:val="1"/></w:numPr><w:jc w:val="left"/></w:pPr><w:r><w:t>A low-pass filter in the space domain. Try different filter (mask) dimensions.</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="ListParagraph"/><w:numPr><w:numId w:val="1"/></w:numPr><w:jc w:val="left"/></w:pPr><w:r><w:rPr><w:b/></w:rPr><w:t>(Optional): </w:t></w:r><w:r><w:t>An ideal low-pass filter in the frequency domain. Try different radii.</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="ListParagraph"/><w:numPr><w:numId w:val="1"/></w:numPr><w:jc w:val="left"/></w:pPr><w:r><w:t>A Gaussian filter. Design it with </w:t></w:r><w:r><w:rPr><w:i/></w:rPr><w:t>fspecial</w:t></w:r><w:r><w:t> and try different parameter values.</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="text"/><w:jc w:val="left"/></w:pPr><w:r><w:t></w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="text"/><w:jc w:val="left"/></w:pPr><w:r><w:t></w:t></w:r></w:p></w:body></w:document>